*geometry.txt*  For Vim version 8.2.  Last change: 2022 May 05


		  VIM REFERENCE MANUAL


Indexing into strings/buffers/windows by line/row/byte/column.	*geometry*


0. String/line indexing		|geometry-string-indexing|
   By byte			|geometry-string-by-byte|
   By character			|geometry-string-by-character|
   By display cell		|geometry-string-by-display-cell|
   Conversion functions		|geometry-string-indexing-conversion|


==============================================================================
0. String/line indexing				*geometry-string-indexing*

Informally, a string is a finite sequence of characters, for example "foobar"
or "여보세요". Vim represents a buffer as a list of strings, one per line, and
provides functions which do things like return the `n`th line of a buffer as a
string.

This section discusses indexing into strings (and therefore buffer lines).
Strings can be indexed by byte, by character (code point), or by display
column (horizontal offset on the screen). Being careful about how you index is
important if you are writing code where horizontal offsets are important, for
example if you are making a plugin for auto-formatting tables.

Strings are normally represented by sequences of bytes (8-bit integers), which
are converted into display characters (like "f" or "여") using a character
encoding, which is essentially a table that maps byte sequences to display
characters. Once interpreted as a sequence of display characters, a string can
be rendered in a terminal or GUI using the terminal or GUI's fonts, display
settings, etc.

In UTF-8 (the usual *'encoding'* used by Vim), the ASCII characters are all
one byte long, but other UTF-8 characters use multiple bytes, and there are
other common encodings such as UTF-16 where all characters use multiple bytes,
so indexing by display character is encoding-dependent. In a terminal, some
characters (all common Latin characters, for example) are one column wide, but
some characters are more than one column wide, so indexing by screen column is
both encoding- dependent and renderer-dependent.


BY BYTE						*geometry-string-by-byte*

Using square brackets to index into a string performs indexing by byte offset,
and is zero-based. The builtin function *strlen* can be used to get the byte
length of a string.

Example:
	:let s = "foobar" ~
	:echo s[0] ~
	(prints "f")
	:echo s[3] ~
	(prints "b")
	:echo strlen(s) ~
	(prints "6")
	:echo "여보세요"[2] ~
	(prints an encoding-dependent byte, `<ac>` in UTF-8)
	:echo strlen("여보세요") ~
	(prints "12" in UTF-8)

See also: *strpart*


BY CHARACTER					*geometry-string-by-character*

The builtin function *strcharpart* can be used to get an arbitrary-length
portion of a string, indexed by character, zero-based. Using this function
with a length argument of 1 is the easiest way to get the `n`th character from
a string.

Example:
	:echo strcharpart("foobar", 3, 2) ~
	(prints "ba")
	:echo strcharpart("foobar", 0, 1) ~
	(prints "f")
	:echo strcharpart("여보세요", 0, 2) ~
	(prints "여보")

The function *strchars* gives the number of characters in a string. The
builtin function *strgetchar* can be used to get the numeric value (usually
Unicode code point) of the `n`th character from a string.

Example:
	:echo strchars("여보세요") ~
	(prints "4")
	:echo strgetchar("여보세요", 2) ~
	(prints 50668)

See also: *slice()*


BY DISPLAY CELL				*geometry-string-by-display-cell*

Some text.


CONVERSION FUNCTIONS			*geometry-string-indexing-conversion*

- *charidx* : convert byte index to character index
- *byteidx* : convert character index to byte index

==============================================================================
0. String indexing				*geometry-string-indexing*

Some text.


BY BYTE						*geometry-string-by-byte*

Some text.


BY CHARACTER					*geometry-string-by-character*

Some text.


BY DISPLAY CELL				*geometry-string-by-display-cell*

Some text.


CONVERSION FUNCTIONS			*geometry-string-indexing-conversion*

Some text.

 vim:tw=78:ts=8:noet:ft=help:norl:
