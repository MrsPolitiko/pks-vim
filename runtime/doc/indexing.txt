*indexing.txt*  For Vim version 8.2.  Last change: 2022 May 05


		  VIM REFERENCE MANUAL


								*indexing*
Indexing into strings/buffers/windows by line/row/byte/column/character.


0. String/line indexing		|indexing-strings|
   By byte			|indexing-strings-by-byte|
   By character			|indexing-strings-by-character|
   By display cell		|indexing-strings-by-display-cell|
   Conversion functions		|indexing-strings-conversion|


==============================================================================
0. String/line indexing				*indexing-strings*

Informally, a string is a finite sequence of characters, for example "foobar"
or "여보세요". Vim represents a buffer as a list of strings, one per line, and
provides functions which do things like return the `n`th line of a buffer as a
string.

This section discusses indexing into strings (and therefore buffer lines).
Strings can be indexed by byte, by character (code point), or by display
column (horizontal offset on the screen). Being careful about how you index is
important if you are writing code where horizontal offsets are important, for
example if you are making a plugin for auto-formatting tables, or a plugin
with an in-buffer UI.

Strings are normally represented by sequences of bytes (8-bit integers), which
are converted into display characters (like "f" or "여") using a character
encoding, which is essentially a table that maps byte sequences to display
characters. Once interpreted as a sequence of display characters, a string can
be rendered in a terminal or GUI using the terminal's or GUI's fonts, display
settings, etc.

In UTF-8 (the usual *'encoding'* used by Vim), the ASCII characters are all
one byte long, but other UTF-8 characters use multiple bytes, and there are
other common encodings such as UTF-16 where all characters use multiple bytes,
so indexing by display character is encoding-dependent. In a terminal, some
characters (all common Latin characters, for example) are one column wide, but
some characters are more than one column wide, so indexing by screen column is
both encoding- dependent and renderer-dependent.


BY BYTE						*indexing-strings-by-byte*

Using square brackets to index into a string performs indexing by byte offset,
and is zero-based. The builtin function *strlen()* can be used to get the byte
length of a string.

Example:
	:let s = "foobar" ~
	:echo s[0] ~
	(prints "f")
	:echo s[3] ~
	(prints "b")
	:echo strlen(s) ~
	(prints "6")
	:echo "여보세요"[2] ~
	(prints an encoding-dependent byte, `<ac>` in UTF-8)
	:echo strlen("여보세요") ~
	(prints "12" in UTF-8)

See also: *strpart()*


BY CHARACTER					*indexing-strings-by-character*

The builtin function *strgetchar()* can be used to get the `n`th character
from a string, and the function *strcharpart()* can be used to get an
arbitrary-length portion of a string. Both of these functions accept character
indices and are zero-based.

Example:
	:echo strgetchar("foobar", 0) ~
	(prints "f")
	:echo strgetchar("foobar", 1) ~
	(prints "o")
	:echo strcharpart("여보세요", 2) ~
	(prints "세")
	:echo strcharpart("foobar", 3, 2) ~
	(prints "ba")
	:echo strcharpart("foobar", 0, 1) ~
	(prints "f")
	:echo strcharpart("여보세요", 0, 2) ~
	(prints "여보")

The function *strchars()* gives the number of characters in a string. The
builtin function *strgetchar()* can be used to get the numeric value (usually
Unicode code point) of the `n`th character from a string.

Example:
	:echo strchars("여보세요") ~
	(prints "4")
	:echo strgetchar("여보세요", 2) ~
	(prints 50668)

See also: *slice()* *strcharlen()*


BY DISPLAY CELL				*indexing-strings-by-display-cell*

The builtin function *strwidth()* gives the width of a string in display
cells.

Example:
	:echo strwidth("여") ~
	(renderer-dependent, but in many terminals prints "2")

See also: *strdisplaywidth()* *setcellwidths()*


CONVERSION FUNCTIONS			*indexing-strings-conversion*

- *charidx()* : convert byte index to character index
- *byteidx()* : convert character index to byte index
- *byteidxcomp()* : like *byteidx()* but count composing characters
- *iconv()* : convert text from one encoding to another

==============================================================================
0. String indexing				*indexing-strings*

Some text.


BY BYTE						*indexing-strings-by-byte*

Some text.


BY CHARACTER					*indexing-strings-by-character*

Some text.


BY DISPLAY CELL				*indexing-strings-by-display-cell*

Some text.


CONVERSION FUNCTIONS			*indexing-strings-conversion*

Some text.

 vim:tw=78:ts=8:noet:ft=help:norl:
