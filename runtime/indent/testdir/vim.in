" vim: set ft=vim sw=4 :

" START_INDENT

func Some()
let x = 1
endfunc

let cmd =
\ 'some '
\ 'string'

if 1
let x = [
\ ]
endif

" TODO: add searchpair() to find matching {
"for x in [
"{
"key: 'value'
"},
"]
"eval 0
"endfor

for x in [
{key: 'value'},
]
eval 0
endfor

let t = [
\ {
\ 'k': 'val',
\ },
\  ]

def Func()
  var d = dd
	->extend({
	})
  eval 0
enddef

" END_INDENT

" START_INDENT
" INDENT_EXE let g:vim_indent_cont = 6

let cmd =
\ 'some '
\ 'string'

" END_INDENT

" START_INDENT
" INDENT_EXE let g:vim_indent_cont = 5

let list = [
\ 'one',
\ 'two']

" END_INDENT

" START_INDENT
" INDENT_EXE unlet g:vim_indent_cont

let list = [
'one',
'two',
]
echo

" END_INDENT

" START_INDENT
" INDENT_AT  this-line
func Some()
let f = x " this-line
endfunc
" END_INDENT

" START_INDENT
" INDENT_NEXT  next-line
func Some()
    " next-line
let f = x
endfunc
" END_INDENT

" START_INDENT
" INDENT_PREV  prev-line
func Some()
let f = x
" prev-line
endfunc
" END_INDENT

" START_INDENT
let a =<< END
nothing
END
" END_INDENT

" START_INDENT
let a =<< trim END
nothing
END
" END_INDENT

" START_INDENT
" INDENT_AT  this-line
let a=<< trim END
   blah
      blah
      blah this-line
END
" END_INDENT

" START_INDENT
if v:true
echo 0
end
" END_INDENT

" START_INDENT
var result = Func(
arg1,
arg2
)
" END_INDENT

" START_INDENT
var result = Func(arg1,
arg2)
" END_INDENT

" START_INDENT
filter(list, (k, v) =>
v > 0)
" END_INDENT

" START_INDENT
filter(list, (k, v) => {
const x = get(list, k, 0)
return x > 0
})
" END_INDENT

" START_INDENT
if x > 0
filter(list, (k, v) => {
const x = get(list, k, 0)
return x > 0
})
endif
" END_INDENT

" START_INDENT
{
var temp = 'temp'
}
" END_INDENT

" START_INDENT
var text = lead
.. middle
.. end
" END_INDENT

" START_INDENT
var text = lead ..
middle ..
end
" END_INDENT

" START_INDENT
var total = start +
end -
correction
" END_INDENT

" START_INDENT
var result = start
:+ print
" END_INDENT

" START_INDENT
var result = positive
? PosFunc(arg)
: NegFunc(arg)
" END_INDENT

" START_INDENT
var result = GetBuilder()
->BuilderSetWidth(333)
->BuilderSetHeight(777)
->BuilderBuild()
" END_INDENT

" START_INDENT
var result = MyDict
.member
" END_INDENT

" START_INDENT
autocmd BufNewFile *.match if condition
|   echo 'match'
| endif
" END_INDENT

" START_INDENT
set cpo+=C
var lines =<< trim END
| this works
END
set cpo-=C
" END_INDENT

" START_INDENT
syn region Text
\ start='foo'
#\ comment
\ end='bar'
" END_INDENT

" START_INDENT
au CursorHold * echom 'BEFORE bar'
#\ some comment
| echom 'AFTER bar'
" END_INDENT

" START_INDENT
def MyFunc(text: string,
separator = '-'
): string
enddef
" END_INDENT

" START_INDENT
def MyFunc(
text: string,
separator = '-'
): string
enddef
" END_INDENT

" START_INDENT
[var1, var2] =
Func()
" END_INDENT

" START_INDENT
const list = ['one',
'two']
" END_INDENT

" START_INDENT
const list = [
'one',
'two',
]
" END_INDENT

" START_INDENT
const dict = {one: 1,
two: 2
}
" END_INDENT

" START_INDENT
const dict = {
one: 1,
two: 2
}
" END_INDENT

" START_INDENT
if true
const dict =
{
one: 1,
two: 2
}
endif
" END_INDENT

" START_INDENT
def Func()
return {
one: 1
}
enddef
" END_INDENT

" START_INDENT
echo {
a: 0,
# b
# c
}
" END_INDENT

" START_INDENT
echo search(
# comment
'1'
.. '2'
)
" END_INDENT

" START_INDENT
if true
var v = (      # trailing "(" starts line continuation
3 + 4      # nothing special
)              # end of expression indicates continued line
var x: number  # needs to align with previous "var"
endif
" END_INDENT

" START_INDENT
def Func() # {{{
# comment
if true
return
endif
enddef
" END_INDENT

" START_INDENT
echo {
key:
'value',
}
" END_INDENT

" START_INDENT
var id = time
->timer_start((_) => {
n = 0
})
" END_INDENT

" START_INDENT
augroup Name
autocmd!
augroup END
" END_INDENT

" START_INDENT
var n =
# comment
1
+ 2

var s = ''
" END_INDENT

" START_INDENT
var keys = {
    J: 'j',
    "\<Home>": '1G',
    "\<End>": 'G',
    z: 'zz'
}
" END_INDENT

" START_INDENT
export def Func(
	n: number,
	s: string,
	...l: list<bool>
	)
enddef
" END_INDENT

" START_INDENT
var heredoc =<< trim ENDD
var nested_heredoc =<< trim END
END
ENDD
" END_INDENT

" START_INDENT
if true
else  " comment
endif
" END_INDENT

" START_INDENT
if true | echo 'one' | endif
if true | echo 'two' | endif
if true | echo 'three' | endif
" END_INDENT

" START_INDENT
if true
:'<-1 mark <
else
echo ''
endif
" END_INDENT

" START_INDENT
substitute/pat /rep /
echo
" END_INDENT

" START_INDENT
try
echo 1
catch /pat /  # comment
echo 2
endtry
" END_INDENT

" START_INDENT
def Func()
Cmd %
enddef
" END_INDENT

" START_INDENT
if end == 'xxx' || end == 'yyy'
echo
endif
" END_INDENT

" START_INDENT
if true
popup_move(id, {col: 1,
line: 2})
endif
setwinvar(id, 'name', 3)
" END_INDENT
